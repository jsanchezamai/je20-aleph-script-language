English version available, please request.

Nota: Se ha codificado el software usando spanish-like intencionalmente. Se dispone version anglosajona.

Sábado, 25 de noviembre de 2024.

En el contexto del proyecto [JE2.0](https://jsanchezamai.github.io/je20/), para un final de grado; en el marco de las asignaturas TLP y FIA, [aleph-script](https://github.com/jsanchezamai/je20-aleph-script-language) supone un intento (dummy, naife) de crear un lenguaje para desarrollar y operar aplicaciones de inteligencia artificial. 

Aunque la cabecera anterior excluye el contenido de este repositorio para cualquier uso fuera de entornos controlados, desde un [punto de vista comercial](./COMERCIAL.md), se ha intentado aproximar un entorno de bucle contínuo (CD/CI) sobre las tecnologías RASA y OpenAI en representación concreta de los servicios de IA que el lenguaje Alephscript, en adelante AS, necesitaría poder manipular. Como se indica, no es objeto de este lenguaje operar en un mundo real sino en el mismo espacio-tiempo en que operan, por definición, las Máquinas de Turing. El presente desarrollo no pretende resolver un problema sino aportar valor dentro un contexto problemático a la hora de servir como herramienta protocolaria en la interconexión de sus agentes. Coletilla comercial: "Aleph script, un lenguaje para gobernarlos a todos". O bien: "¿Quieres hablar el lenguaje de la Inteligencia Artificial General? Habla Alephscript".

# Justificación del proyecto

Cuentan que Ada Lovelace flirteraba con Babagge; en un momento de la historia en que la inteligencia artificial no se concebía. 

El profesor simplemente quería activar la potencia de análisis en las modernas calculadoras de ecuaciones que la matemática había fundado en máquinas teóricas de cálculo diferencial; que medían, con sistemas de ecuaciones computados al unísono, el cambio de estado a lo largo del tiempo. El profesor, a parte de medir el cambio de estado, quería inferir tanto los estados anteriores como los que devendrían. Ada, que participaba en su proyecto, además, entendía que, si las disquisiciones analíticas de Babbage funcionaban, entonces, se necesitarían órdenes analíticas para que la máquina procediera a la inferencia y su consecuente actividad. Es decir, Ada sintió la necesidad de inventar "lenguajes de programación".

La electricidad tuvo que aparecer en nuestro entramado industrial antes de que arreciara la electrónica (no digital) a pie de máquina, programando lógica concreta para sus capacidades, entrecruzando sabiamente circuiteria lógica de puertas digitales, dentro de un entramado de control que, en su esencia, cuenta de a uno para escoger turno en una lista de instrucciones esperando ser ejecutadas. Soportado tal dinamismo en un pequeño o enorme banco de registros, la concepción de placa madre culmina esta época electrónica inventando la orquesta perfecta. Con la que, desde entonces, se tocan las más variopintas músicas digitales. Entradas, operaciones, salidas. Muy similar a como cuando soplamos, modulamos acorde y oímos nuestros instrumentos. Una misma herramienta, un infinito de canciones.

Desde tiempos de programación procedural a pie de máquina hasta el punto temporal en que alguien plantea la necesidad de crear un lenguaje específico para orquestar inteligencias artificiales han pasado distintos estados de TLP y FIA que tendré el gusto de otear con mirada de estudiante el 2ndo cuatrimestre 2023-2024, y que me permtirán continuar con esta sección del documento con mayor solvencia. Solo remarcar, por el momento, mi absoluta especialización en programación estructurada orientada a objetos (digno sucesor de la teoría de marcos de Minksy) si bien reconozco la importancia y el hype que lenguajes declarativos como Prolog (lenguaje que practicaré con FIA) suponen hoy día para la inteligencia artificial. Haskell, otro ejemplo, en este caso, quizás, más académico, (de TLP) y la técnica de backtraking como principio motor semántico para convertir gramáticas en producciones concretas que permitan derivar cadenas concretas, deterministas, expresiones del sistema y su estado.

La vuelta atrás, inspiración en bucles o motivos de recursividad, explora un espacio valorando las opciones en un movimiento de va y viene recorriendo exhaustivamente el árbol de probabilidad. Naturaleza esencial en una derivación gramátical desde las producciones a las cadenas de lenguaje resultantes.

Aunque las redes neuronales artificiales, y las redes convulacionales como sus estrellas más brillantes, se hayan desplegado en el cielo de repositorios de la nube en un millar de modelos (capas y capas de perceptrones, más o menos ponderados, tras su entrenamiento), el mundo de la inteligencia artificial hunde sus raíces en los sistemas de agentes aprendiendo por refuerzo (metas/recompensa) en un contexto de inventario y agentes pugnando/colaborando por él. El proceso mimético bioinformático establece generaciones que disponen de un tiempo de vida (pugna por el inventario) antes de ser seleccionado genéticamente (solo pasan a la siguiente época un subconjunto de esos gentes, la de aquellos agentes cuyas decisiones facilitaron mayor recompensa). Los dos grandes superpoderes de estas redes neuronales: separar los elementos de un hiperplano mediante una línea que los diverge (clasificación); situar una línea de referencia media en ese espacio de modo que evidencie la desviación de las muestras respecto del patrón (regresión). Las dos super técnicas que dan superpoderes de clasficación y regresión, que es una: optimización, la minimización o la maximización de un problema escogiendo, entre sus posibles soluciones, la óptima.

El sueño de Ada: "programar algoritmos para que hagan cosas", hoy día, pasó a una fase de "programar algoritmos para que programen otros algoritmos que hagan cosas". La propuesta Alephscript va a la definición de una gramátíca totalmente determinista (un lenguaje contenido (sub-clase) en el lenguaje natural) pero aportando n grados de libertad (configurable según necesidad de producto) en su compilación a lenguaje artificial.

Una gramática se compone de cuatro elementos: dos listas de léxico, un conjunto inicial y una lista de reglas (producciones). Las listas de léxico: una contiene elementos terminales; y la otra toma la forma de arcos de relación entre aquellos. Una cadena de lenguaje que sea derivable desde la definición de su gramática y el elemento inicial será válida para entregársela a una máquina, instancia del sueño de Ada ahora aplicado a las FIAs. Derivar, entonces, supone recorrer el árbol gramatical y reunir en una frase los nodos resultantes del recorrido.

Si bien los logros en lenguaje natural que los grandes modelos hoy disponibles (ChatGPT, LLama2,...) son reseñables, no es menos cierto que todavía no se ha madurado esfuerzo para logros en lenguaje artificial. Si el natural es humano-a-humano, el lenguaje artificial sería humano-a-automata, y, en última instancia, como propone Alephscript, humano-a-máquina.

Alephscript entronca con la naturaleza versátil y fibrosa (como spaguetthis) de javascript que supo aparecer en el momento en que los navegadores levantaron a las aplicaciones de los escritorios en redes locales. La aparición de unas máquinas de ejecución dentro de los navegadores (agnósticas por tanto respecto del sistema operativo visitante) hoy día se ensancha con WebAssembly disputando el espacio en la trastienda del navegador a la v8 de Google, hegemónica en el mundo Web. La necesidad de completar la experiencia UX/UI de usuarios navegando en las apps con servicios AI convierte, de nuevo, al código binario próximo al código máquina en una necesidad acuciante. Saltando como salta typescript sobre javascript, alephscript es un cuarto superset que aprovecha el determinismo tipado de typscript con el indeterminismo tipo hebra de javascript. Si bien el proyecto parte desde la plataforma agnóstica NodeJs, es previsible la migración a DENO. En cualquier caso, el lenguaje no debe comprometerse a la vía AS/TS/JS/v8 sino centrar la producción de binarios en WebAssembly, contando el enorme agnosticismo respecto de las tecnologías en curso, ofreciendo servicios de inteligencia a las aplicaciones.

Nota solo para la presentación de este documento en el marco BIT 2023:

Presunción que la crisis en OpenAI fue por liberar Q*.

Q* más, sobre la assistance API, emula una máquina de turing. La cinta son los threads, y el cabezal son los runners. El asterisco podría hacer referencia a la clausura de Kleanee, saturación total de un lenguaje enumerando cada uno de sus integrantes. La condición turing-completa de una máquina y un lenguaje augura que Q* podría ser la clausura positiva completa de un lenguaje y así significar la mismísima Inteligencia Artificial de Propósito General.

La pugna en la bicefalia de OpenAI estaría entre quienes querrían definir a la IA como "el hito científico-académico-humanista más grande de los últimos tiempos, un paso más hacia la comprensión de nuestras propias inteligencias sapiens" y los que prefirirían definir: "La IA es una algoritmia capaz de ejecutar tareas con valor económico". Entre quienes querrían contener Q* como herramienta especializada (de calidad teórica, experimental) o quienes ansian comercializarla en el mercado amplio e integrarlas en sus plataformas de servicio. Sin ser capaces de posicionarnos, en esta presentación observamos la necesidad de lenguajes que permitan interactuar con las máquinas tanto para desarrollar sus inteligencias como para operarlas. En ese espacio aterrizamos para ofrecer solución a una necesidad. O, quizás, oportunidad. ¿Podría una AGI (por las siglas en inglés), supuestamente por advenir o ya advenida (Q*), podría necesitar lenguajes específicos para hacer eso que Ada Lovelace agregó de extra en las notas de traducción de la conferencia 'devDays 1837' en que, sin tener un Microsoft, buscaban financiación para su máquina?

Si así fuera, Alephscript es un candidato.

Laboratorios y versión experimental en AlephScript: [un lenguaje para FIAs](https://github.com/jsanchezamai/je20-aleph-script-language/blob/alephscript_v0001/README_TECNICO.md) (unidades fundamentales de inteligencia artificial). Primer ejemplo de uso: [Modelización cadena de montaje (robots Kuka)](https://github.com/jsanchezamai/je20-aleph-script-language/blob/alephscript_v0001/src/FIA/aplicaciones/cadena/README.md).

