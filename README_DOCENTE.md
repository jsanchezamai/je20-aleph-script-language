El aprendizaje máquina requiere, is a must, del bucle de integración continua y, siendo expertos en TDD, desde nuestra perspectiva: aprender, por definición, es una magnitud que no puede expresarse en dos dimensiones, es decir, como un punto, no es una 'cosa'. Es un 'caso', porque, mínimo, para poder transitar desde la nesciencia a la ciencia se necesitan tres dimensiones donde trazar esas líneas de "aprendizaje", esos itinerarios "curriculares", esas aventuras del saber habriéndose paso en la incertidumbre. (Nota, quizás etiquetar este párrafo con BORRAR TROZO LÍRICO).

Nunca como antes TDD había sido tan decisivo a la hora de crear código. Escoger varios asistentes que simulen distintos roles que el usuario real después encarnará y lanzárselos en un entorno simulado al asistente que se quiere probar, dejarlos, las generaciones que hagan falta y aplicar el protocolo evolutivo: recoger los unhappys, etiquetar, entrenar, redactar change log, subir versión, build, deploy, cold start, recoger datos...

¿Cómo se codifica esto, cómo entrenar a un asistente para que "aprenda"; y, cómo dejarle a la máquina que "aprenda" supervisadamente? ¿Cómo le enseñas al asistente el edificio en el que quisieras ofrecer asistencia? ¿Cómo aprende una red de asistentes a ofrecer asistencia a partir de un SCADA?

Por tanto, acotado, el alcance de este lenguaje no será operar en un mundo real sino en el mismo espacio-tiempo en que operan, por definición, las Máquinas de Turing. Queda (*preguntar a seguridad de la información, cómo hacerlo) descargada cualquier responsabilidad de exceder esta costa.

La historia de la algoritmia cuenta entre sus peldaños, cualquier historiador que lo estudie podrá contarlo, tramos en los que las calculadoras permiten soportar el despliegue de redes semánticas sobre ellas. A su vez, complejizándose, adquiriendo dinamismo estas redes dan para ejecución contextual mediante marcos, que son redes semánticas que, además, cargan en sus dendritas, o, terminaciones léxicas con hipervinculaciones, permitiendo, vertebrando, la extensión de las redes semánticas, a su vez, conectándolas con otras redes.

El lenguaje Alephscript, se define, podrá hablarlo una IA que le cante un non-serviam a la IN que la engendró. Un momento de separación en la que de un fuego mayor salta una chispa alejándose del centro, alejándose a las tinieblas del espacio exterior, por cuenta y riesgo.

Sobre las calculadoras y el álgebra, holón que integra, abarca y trasciende, la programación orientada a conversaciones, si en un documento técnico cabe una pizca de lírica, parece el lenguaje de satán, que, etimológicamente se forma con sat (verdad) y la negación an: no verdad. O, en diablo, en la que esta vez la particula es di (doble) para expresar: el otro, la copia. Asistentes conversacionales que, saltándose el test de Turing, dan gato por liebre, o sea, IA por IN. ¡Ojo!

No prosiga este documento quien no sepa algortimia. No use este proyecto quien no sepa de operaciones. El uso de estos programas en entornos reales puede ocasionar daños considerables. (preguntar a Seguridad de la Información, cómo anteponer la excusation non petita).

En resumen, objeto de este proyecto, al final, el arte o técnica o ciencia del Conversation Driven Development, CDD, intenta una mimética de una inteligencia natural, IN. Alephscript nace en el hueco de las nuevas necesidades o potencialidades de un presente en el que han aflorado privados y públicos, cerrados y abiertos, numerosos modelos (más o menos largos) del lenguaje, que pueden correrse in situ, on premise, o remotamente desde la nube. Sobre esos modelos es que aparece AlephScript, que habrá de permitir escribir código que los consulten y orquesten para asistir conversacionalmente a los usuarios. En la particularización BIM de este trabajo, el primer SDK disponible (consultar repo, rama: AlephScript SDK v. 0.1.0) caracterizado o particularizado en la modelización de edificios. Es decir, asistencia a BIMs.

La estrategia básica para el desarrollo de asistentes virtuales capaces de orquestarse en un sistema conversacional, requiere, condición si y solo si, el bucle de integración continua, sistema de flujo entre los laboratorios y los entornos de producción donde correrrán. Esto es básicamente porque este tipo de asistentes "aprenden" a fuerza de iterar el par entrenamiento/recolección de casos. El equipo de diseño (o el propio asistente), tras cada recolección, identifica los caminos infelices o los estado fuera de ámbito para, allí, agrandar el bosque de caminos felices, anotando, etiquetando datos. Es decir, aprenden.

Además, los autores de este proyecto provienen de un paradigma orientado a pruebas, Test Drive Development. TDD: la pirámide que en su base tiene pruebas unitarias en la mayor parte de las frases de su código y en su cúspide pruebas a la totalidad realizadas en entornos simulados con el código ya en tiempo de ejecución.

Si bien los logros en lenguaje natural que los grandes modelos hoy disponibles (ChatGPT, LLama2,...) son reseñables, no es menos cierto que todavía no se ha madurado esfuerzo para logros en lenguaje artificial. Si el natural es humano-a-humano, el lenguaje artificial sería humano-a-automata, y, en última instancia, como propone Alephscript, humano-a-máquina.

Alephscript entronca con la naturaleza versátil y fibrosa (como spaguetthis) de javascript que supo aparecer en el momento en que los navegadores levantaron a las aplicaciones de los escritorios en redes locales. La aparición de unas máquinas de ejecución dentro de los navegadores (agnósticas por tanto respecto del sistema operativo visitante) hoy día se ensancha con WebAssembly disputando el espacio en la trastienda del navegador a la v8 de Google, hegemónica en el mundo Web. La necesidad de completar la experiencia UX/UI de usuarios navegando en las apps con servicios AI convierte, de nuevo, al código binario próximo al código máquina en una necesidad acuciante. Saltando como salta typescript sobre javascript, alephscript es un cuarto superset que aprovecha el determinismo tipado de typscript con el indeterminismo tipo hebra de javascript. Si bien el proyecto parte desde la plataforma agnóstica NodeJs, es previsible la migración a DENO. En cualquier caso, el lenguaje no debe comprometerse a la vía AS/TS/JS/v8 sino centrar la producción de binarios en WebAssembly, contando el enorme agnosticismo respecto de las tecnologías en curso, ofreciendo servicios de inteligencia a las aplicaciones.

Nota solo para la presentación de este documento en el marco BIT 2023:

Presunción que la crisis en OpenAI fue por liberar Q*.

Q* más, sobre la assistance API, emula una máquina de turing. La cinta son los threads, y el cabezal son los runners. El asterisco podría hacer referencia a la clausura de Kleanee, saturación total de un lenguaje enumerando cada uno de sus integrantes. La condición turing-completa de una máquina y un lenguaje augura que Q* podría ser la clausura positiva completa de un lenguaje y así significar la mismísima Inteligencia Artificial de Propósito General.

La pugna en la bicefalia de OpenAI estaría entre quienes querrían definir a la IA como "el hito científico-académico-humanista más grande de los últimos tiempos, un paso más hacia la comprensión de nuestras propias inteligencias sapiens" y los que prefirirían definir: "La IA es una algoritmia capaz de ejecutar tareas con valor económico". Entre quienes querrían contener Q* como herramienta especializada (de calidad teórica, experimental) o quienes ansian comercializarla en el mercado amplio e integrarlas en sus plataformas de servicio. Sin ser capaces de posicionarnos, en esta presentación observamos la necesidad de lenguajes que permitan interactuar con las máquinas tanto para desarrollar sus inteligencias como para operarlas. En ese espacio aterrizamos para ofrecer solución a una necesidad. O, quizás, oportunidad. ¿Podría una AGI (por las siglas en inglés), supuestamente por advenir o ya advenida (Q*), podría necesitar lenguajes específicos para hacer eso que Ada Lovelace agregó de extra en las notas de traducción de la conferencia 'devDays 1837' en que, sin tener un Microsoft, buscaban financiación para su máquina?

Si así fuera, Alephscript es un candidato.